<html lang="en_US">

<head>
  <title>Use inheritance for my first program (cpp) : Setting up the program </title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <link href="../../style/ontologenius_api.css" rel="stylesheet" type="text/css">
  <link href="../../images/favicon.ico" rel="shortcut icon">
  <link href="../../images/favicon-32x32.png" rel="icon" type="image/png">
  <link href="../../images/favicon-16x16.png" rel="icon" type="image/png">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
</head>

<body>
  <div class="header" id="header">
    <header class="fixed" id="navbar">
      <div class="container">
          <div class="navbar-header">
            <div id="header-buttons">
                <ul id="header-ul" data-event="hover_intent" data-effect="fade" data-effect-speed="500">
                    <li class="header-item"><a class="header-link" href="https://github.com/sarthou/ontologenius" tabindex="0"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/Octicons-mark-github.svg/1200px-Octicons-mark-github.svg.png" alt="github" width="40px" height="40px"/></a></li>
                </ul>
            </div>
            <a class="navbar-icon" href="../../index.html">
              <img src="../../images/ontologenius.png " alt="ontologenius" width="65px" height="65px"/>
            </a>
        </div>
      </div>
    </header>
  </div>

  <div class="main">

    <div class="navigationbar">
      <ul class="sub-navigation">
        <li><a href="https://github.com/sarthou/ontologenius/tree/master/src/API/ontologenius">C++ API sources</a></li>
        <li><a href="https://github.com/sarthou/ontologenius/tree/master/include/ontologenius/API/ontologenius">C++ API headers</a></li>
        <li><a href="https://github.com/sarthou/ontologenius/tree/master/ontopy/ontologenius">Pyhton API sources</a></li>
        <li><a href="https://gitlab.com/sarthou/ontologenius/pipelines">Pipelines</a></li>
      </ul>
      <h1>Ontologenius Cpp Documentation</h1>
    </div>

    <div class="content">
      <div class="sidebar" style="transition: all 0.2s ease-out 0s; top: -270px;">
        <div class="contents">
          <div id="contents-toggle" class=""></div>
          <h3>Contents</h3>
          <ul style="display: block;">
            <li class="level1"><a href="settingUpTheProgram.html"><b>1. Setting up the program</b></a></li>
            <li class="level1"><a href="LaunchTheProgram.html">2. Launch the program</a></li>
            <li class="level1"><a href="FindTheIntruder.html">3. Find the intruder</a></li>
            <li class="level1"><a href="MostRelevantIntruder.html">4. Find the most relevant intruder</a></li>
            <li class="level1"><a href="ManageTheMultilingual.html">5. Manage the multilingual</a></li>
          </ul>
        </div>

        <div class="contents">
          <div id="contents-toggle" class=""></div>
          <h3>Getting Start</h3>
          <ul style="display: block;">
            <li class="level1"><a href="../../Download.html">Download</a></li>
            <li class="level1"><a href="../../InstallOntologenius.html">Install Ontologenius</a></li>
            <li class="level1"><a href="../../SetUp.html">Set Up Your Environnement</a></li>
            <li class="level1"><a href="../Tutorials.html">Cpp Tutorials</a></li>
            <li class="level1"><a href="../../python_Tutorials/Tutorials.html">Python Tutorials</a></li>
          </ul>
        </div>

        <div class="contents">
          <div id="contents-toggle" class=""></div>
          <h3>Overview</h3>
          <ul style="display: block;">
            <li class="level1"><a href="../../overview/launchers.html">Launchers</a></li>
            <li class="level1"><a href="../../overview/ontoloGUI.html">OntoloGUI</a></li>
            <li class="level1"><a href="../../overview/reasonersConfiguration.html">Reasoners configuration</a></li>
            <!--li class="level1"><a href="plugins.html">Plugins</a></li-->
          </ul>
        </div>

        <div class="contents">
          <div id="contents-toggle" class=""></div>
          <h3>
            <i class="fas fa-angle-down"></i>
            <a href="../../cpp_API/CppAPI.html">
              All C++ Classes
            </a>
          </h3>
          <ul style="display: block;">
            <li class="level1"><a href="../../cpp_API/ActionClient.html">ActionClient</a></li>
            <li class="level1"><a href="../../cpp_API/ClassClient.html">ClassClient</a></li>
            <li class="level1"><a href="../../cpp_API/ClientBase.html">ClientBase</a></li>
            <li class="level1"><a href="../../cpp_API/DataPropertyClient.html">DataPropertyClient</a></li>
            <li class="level1"><a href="../../cpp_API/FeederPublisher.html">FeederPublisher</a></li>
            <li class="level1"><a href="../../cpp_API/IndividualClient.html">IndividualClient</a></li>
            <li class="level1"><a href="../../cpp_API/ManagerClient.html">ManagerClient</a></li>
            <li class="level1"><a href="../../cpp_API/ObjectPropertyClient.html">ObjectPropertyClient</a></li>
            <li class="level1"><a href="../../cpp_API/OntologiesManipulator.html">OntologiesManipulator</a></li>
            <li class="level1"><a href="../../cpp_API/OntologyClient.html">OntologyClient</a></li>
            <li class="level1"><a href="../../cpp_API/OntologyManipulator.html">OntologyManipulator</a></li>
            <li class="level1"><a href="../../cpp_API/ReasonerClient.html">ReasonerClient</a></li>
            <li class="level1"><a href="../../cpp_API/SparqlClient.html">SparqlClient</a></li>
          </ul>
          </br>
          <h3>
            <i class="fas fa-angle-right"></i>
            <a href="../../python_API/PythonAPI.html">
              All Python Classes
            </a>
          </h3>
        </div>
      </div>

      <div class="context">
        <div class="toturial-header">
          <h1 class="title">Use inheritance for my first program (cpp)</h1>
          <a class="toturial-subheader">
            <div class="tutorial-subheader__main-icon">
              <i class="fas fa-brain"></i>
            </div>
            <div class="toturial-subheader__title">
              <h2 class="title">Who is the intruder ?</h2>
            </div>
          </a>
        </div>

        <h1 class="title">Setting up the program </h1>

        <p>Welcome to this first Ontologenius tutorial. In this tutorial, we will take over the Ontologenius
          API using an OntologyManipulator. This is the most important thing you need to know to use
          Ontologenoius in a simple way. We will also see how to launch Ontologenius by configuring it according
          to our needs.</p>

        <p>To illustrate the different objectives of this tutorial, we will develop a mini-games that will
          consist of finding the intruder among a list of words. However, finding only the intruder is a
          much too simple problem. That's why we will also try to find the reason why one word is the intruder
          among the others.</p>

        <p>In this part, we will code the bases of our program from which we will be able to write the more
          algorithmic part. Before that, I invite you to create a new package that we will call &quot;ontologenius_tutorial&quot;
          and which will contain only one source file that we will name &quot;main.cpp&quot;. To be sure that your
          new package will be well configured to use Ontologenius, we advise you to follow this <a target="_blank" rel="noopener noreferrer" href="../../SetUp.html"><b>guide</b></a>.
          We will just rename our executable &quot;intruder&quot; because it is much more logical than &quot;my_exe&quot;.</p>

        <div class="code_block">
            <div class="terminal_line">add_executable(intruder src/main.cpp)</div>
            <div class="terminal_line">target_link_libraries(intruder ${ontologenius_LIBRARIES})</div>
        </div>

        <p>Now we are ready! Let's open our main file and start coding:</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 0;">
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&lt;iostream&gt;</span></div>
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&lt;vector&gt;</span></div>
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&lt;string&gt;</span></div>
          <div class="code_line"><br></div>

          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&quot;ros/ros.h&quot;</span></div>
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&quot;std_msgs/String.h&quot;</span></div>
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&quot;ontologenius/OntologyManipulator.h&quot;</span></div>
          <div class="code_line"><br></div>

          <div class="code_line"><span class="cpp_type">OntologyManipulator</span><span class="cpp_op">*</span> onto_;</div>
          <div class="code_line">std::<span class="cpp_type">vector</span>&lt;std::<span class="cpp_type">string</span>&gt; names_;</div>
          <div class="code_line"><span class="cpp_type">bool</span> start_;</div>
          <div class="code_line"><br></div>

          <div class="code_line"><span class="cpp_type">void</span> say(std::<span class="cpp_type">string</span> text)</div>
          <div class="code_line">{</div>
          <div class="code_line">  std::cout <span class="cpp_op">&lt;&lt;</span> <span class="cpp_string">&quot;[SAY]&quot;</span> <span class="cpp_op">&lt;&lt;</span> text <span class="cpp_op">&lt;&lt;</span> std::endl;</div>
          <div class="code_line">}</div>
          <div class="code_line"><br></div>

          <div class="code_line">std::<span class="cpp_type">string</span> summarize(std::<span class="cpp_type">vector</span>&lt;std::<span class="cpp_type">string</span>&gt; words)</div>
          <div class="code_line">{</div>
          <div class="code_line">  std::<span class="cpp_type">string</span> to_say <span class="cpp_op">=</span> <span class="cpp_string">&quot;on &quot;</span>;</div>
          <div class="code_line">  <span class="cpp_op">for</span>(<span class="cpp_type">size_t</span> i <span class="cpp_op">=</span> <span class="cpp_value">0</span>; i <span class="cpp_op">&lt;</span> words.size(); i<span class="cpp_op">++</span>)</div>
          <div class="code_line">    to_say <span class="cpp_op">+=</span> words[i] <span class="cpp_op">+</span> <span class="cpp_string">&quot; &quot;</span>;</div>
          <div class="code_line">  <span class="cpp_return">return</span> to_say;</div>
          <div class="code_line">}</div>
          <div class="code_line"><br></div>

          <div class="code_line"><span class="cpp_type">void</span> wordCallback(<span class="cpp_op">const</span> std_msgs::<span class="cpp_type">String</span><span class="cpp_op">&</span> msg)</div>
          <div class="code_line">{</div>
          <div class="code_line">  <span class="cpp_op">if</span>(msg.data <span class="cpp_op">==</span> <span class="cpp_string">&quot;start&quot;</span>)</div>
          <div class="code_line">    start_ <span class="cpp_op">=</span> <span class="cpp_value">true</span>;</div>
          <div class="code_line">  <span class="cpp_op">else if</span>(std::find(names_.begin(), names_.end(), msg.data) <span class="cpp_op">==</span> names_.end())</div>
          <div class="code_line">    names_.push_back(msg.data);</div>
          <div class="code_line">}</div>
          <div class="code_line"><br></div>
        </div>

        <p>Take a break here, we have already written a lot. We will go over all this in detail to better
           understand what we have done.</p>
        <p>First of all, we have all the inclusions we need, like iostream to display messages on the screen,
          then vectors and strings to get vectors and strings ...</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 4;">
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&quot;ros/ros.h&quot;</span></div>
        </div>
        <p>ros/ros.h is a convenience include that includes all the headers necessary to use the most common
          public pieces of the ROS system.</p>
        <div class="code_block cpp_code" style="counter-reset:code_line 5;">
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&quot;std_msgs/String.h&quot;</span></div>
        </div>
        <p>This includes the std_msgs/String message, which resides in the std_msgs ROS package. We use
          it to create a topic on which we will send the words from which our program will have to find the
          intruder. </p>
        <div class="code_block cpp_code" style="counter-reset:code_line 6;">
          <div class="code_line"><span class="cpp_include">#include</span> <span class="cpp_included">&quot;ontologenius/OntologyManipulator.h&quot;</span></div>
        </div>
        <p>This includes what we call an ontology manipulator. In fact, this class is just an object to access
          all API ROS abstraction classes so that you can query and manage ontologenius. You can find the
          documentation for this object on the left panel.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 8;">
          <div class="code_line"><span class="cpp_type">OntologyManipulator</span><span class="cpp_op">*</span> onto_;</div>
        </div>
        <p>As explained above, the ontology manipulator contains several objects to abstract ROS services.
          The set of services work in a connected mode which allows to greatly save in execution time but
          which makes the program less robust. For the lack of robustness, each ontologenius client takes care
          of everything for you by implementing recovery mechanisms. As for the connected mode, this means
          that the connection is established at the creation of the object and is broken only at its destruction.
          So we understand that it is better to avoid creating several ontology manipulators but it is better to
          create a single instance for our entire program. This pointer is used to collect the address of this
          single instance to make it available to different functions. However, we do not directly create a global
          instance of a manipulator because it needs a pointer to a NodeHandle of ROS.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 9;">
          <div class="code_line">std::<span class="cpp_type">vector</span>&lt;std::<span class="cpp_type">string</span>&gt; names_;</div>
        </div>
        <p>This vector will allow us to store the different words on which we will perform our search for the intruder.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 10;">
          <div class="code_line"><span class="cpp_type">bool</span> start_;</div>
        </div>
        <p>This is our synchronization variable. This variable will be false as long as we continue to collect
          words and we will put it in the true state as long as we wish to start the search for the intruder.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 12;">
          <div class="code_line"><span class="cpp_type">void</span> say(std::<span class="cpp_type">string</span> text)</div>
        </div>
        <p>Here, the say function is actually just an on-screen display, but you can customize it to use a TTS
           for example.</p>

         <div class="code_block cpp_code" style="counter-reset:code_line 17;">
           <div class="code_line">std::<span class="cpp_type">string</span> summarize(std::<span class="cpp_type">vector</span>&lt;std::<span class="cpp_type">string</span>&gt; words)</div>
         </div>
         <p>Here, the summarize function concatenates several words in a single string. We created this function
           just to make our main function more readable.</p>

         <div class="code_block cpp_code" style="counter-reset:code_line 25;">
           <div class="code_line"><span class="cpp_type">void</span> wordCallback(<span class="cpp_op">const</span> std_msgs::<span class="cpp_type">String</span><span class="cpp_op">&</span> msg)</div>
         </div>
         <p>Here we have the callback function of our input topic. This topic thus receives strings which
           will be the words from which our program will have to find the intruder. Inside the function,
           we can see that we use the word &quot;start&quot; as a synchronization word that will launch our reasoning.
           The different words of &quot;strat&quot; are then stored in the vector names_ pending processing.
           To add security, line 30 verifies that the word is not already present in the names_ vector to
           avoid duplicates.</p>

        <p><br><br>We have everything we need to start writing the main function to retrieve the list of words
          to work on and start the reasoning although we do not have it yet.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 33;">
          <div class="code_line"><span class="cpp_type">int</span> main(<span class="cpp_type">int</span> argc, <span class="cpp_type">char</span><span class="cpp_op">**</span> argv)</div>
          <div class="code_line">{</div>
          <div class="code_line">  ros::init(argc, argv, <span class="cpp_string">&quot;intruder&quot;</span>);</div>
          <div class="code_line"><br></div>
          <div class="code_line">  ros::<span class="cpp_type">NodeHandle</span> n;</div>
          <div class="code_line">  <span class="cpp_type">OntologyManipulator</span> onto;</div>
          <div class="code_line">  onto_ <span class="cpp_op">= &</span>onto;</div>
          <div class="code_line"><br></div>
          <div class="code_line">  onto.close();</div>
          <div class="code_line"><br></div>
          <div class="code_line">  ros::<span class="cpp_type">Subscriber</span> sub <span class="cpp_op">=</span> n.subscribe(<span class="cpp_string">&quot;intruder/input&quot;</span>, 1, wordCallback);</div>
          <div class="code_line">  ros::<span class="cpp_type">Rate</span> r(<span class="cpp_value">100</span>); <span class="cpp_comment"> // 10 hz</span></div>
          <div class="code_line"><br></div>
          <div class="code_line">  <span class="cpp_op">while</span>(ros::ok())</div>
          <div class="code_line">  {</div>
          <div class="code_line">    start_ <span class="cpp_op">=</span> <span class="cpp_value">false</span>;</div>
          <div class="code_line"><br></div>
          <div class="code_line">    say(<span class="cpp_string">&quot;Let's play!&quot;</span>);</div>
          <div class="code_line"><br></div>
          <div class="code_line">    <span class="cpp_op">while</span>((start_ <span class="cpp_op">==</span> <span class="cpp_value">false</span>) <span class="cpp_op">&&</span> ros::ok())</div>
          <div class="code_line">    {</div>
          <div class="code_line">      ros::spinOnce();</div>
          <div class="code_line">      r.sleep();</div>
          <div class="code_line">    }</div>
          <div class="code_line"><br></div>
          <div class="code_line">    say(summarize(names_));</div>
          <div class="code_line"><br></div>
          <div class="code_line">    <span class="cpp_comment">/*</span></div>
          <div class="code_line">    <span class="cpp_comment">We will find the intruder here</span></div>
          <div class="code_line">    <span class="cpp_comment">*/</span></div>
          <div class="code_line"><br></div>
          <div class="code_line">    names_.clear();</div>
          <div class="code_line">  }</div>
          <div class="code_line"><br></div>
          <div class="code_line">  <span class="cpp_return">return</span> <span class="cpp_value">0</span>;</div>
          <div class="code_line">}</div>
        </div>

        <p>Now, let's break the code down.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 35;">
          <div class="code_line">  ros::init(argc, argv, <span class="cpp_string">&quot;intruder&quot;</span>);</div>
          <div class="code_line"><br></div>
          <div class="code_line">  ros::<span class="cpp_type">NodeHandle</span> n;</div>
        </div>
        <p>Initialize ROS and Create a handle to this process' node.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 38;">
          <div class="code_line">  <span class="cpp_type">OntologyManipulator</span> onto;</div>
          <div class="code_line">  onto_ <span class="cpp_op">= &</span>onto;</div>
        </div>
        <p>We finally come back to using ontologenius! We create here our first manipulator ontology,
           what a great day ... This manipulator is unique to fully enjoy the benefits of connected
           services.</p>
        <p>We do not forget to initialize the pointer on the manipulator by providing the address.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 41;">
          <div class="code_line">  onto.close();</div>
        </div>
        <p>The close function link all the concepts loaded from files and the Internet.
          Before closing an ontology, exploration requests are not allowed.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 41;">
          <div class="code_line">  onto.actions.fadd(<span class="cpp_string">&quot;path/to/may/file.owl&quot;</span>);</div>
          <div class="code_line">  <span class="cpp_comment">// OR</span></div>
          <div class="code_line">  onto.actions.add(<span class="cpp_string">&quot;http://path/to/my/file.owl&quot;</span>);</div>
          <div class="code_line">  onto.close();</div>
        </div>
        <p>For the moment, we are going to consider that the ontological file we are
          going to work on is provided in the ontologenius launcher. We will configure
          it in the next part of the tutorial. It is also possible to load files directly
          from the program (as above) but in doing so it makes our code less reusable.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 43;">
          <div class="code_line">  ros::<span class="cpp_type">Subscriber</span> sub <span class="cpp_op">=</span> n.subscribe(<span class="cpp_string">&quot;intruder/input&quot;</span>, 1, wordCallback);</div>
        </div>
        <p>We initialise our subscriber to the topic &quot;intruder/input&quot;. We also
          link this topic to our callback function.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 46;">
          <div class="code_line">  <span class="cpp_op">while</span>(ros::ok())</div>
        </div>
        <p>Just our almost infinite loop. Escaping with a Ctrl + C.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 48;">
          <div class="code_line">    start_ <span class="cpp_op">=</span> <span class="cpp_value">false</span>;</div>
          <div class="code_line"><br></div>
          <div class="code_line">    say(<span class="cpp_string">&quot;Let's play!&quot;</span>);</div>
        </div>
        <p>We initialize the synchronization variable and inform the user that the program is ready to
          listen to the words.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 52;">
          <div class="code_line">    <span class="cpp_op">while</span>((start_ <span class="cpp_op">==</span> <span class="cpp_value">false</span>) <span class="cpp_op">&&</span> ros::ok())</div>
        </div>
        <p>We only wait for the synchronisation... </p>
        <p class="tip">ros::spinOnce() is there to allow us to receive messages via the subject and r.sleep()
          avoids unnecessary use of the processor.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 58;">
          <div class="code_line">    say(summarize(names_));</div>
        </div>
        <p>We recall the words on which we will make the reasoning. It is just as a result of this that
          we will implement our reasoning.</p>

        <div class="code_block cpp_code" style="counter-reset:code_line 64;">
          <div class="code_line">    names_.clear();</div>
        </div>
        <p>Our loop is over, we can erase the words we used and start over!</p>

        <p>Now, you just have to compile that before going on to the following:</p>
        <div class="code_block">
          <div class="terminal_line">catkin_make</div>
        </div>
        <p class="tip">Do not forget that this command must be done in your catkin workspace</p>


        <nav class="course-pagination">
          <a href="../Tutorials.html" class="course-pagination__btn">
            <i class="fas fa-angle-left"></i>
            <span>Tutorials</span>
          </a>
          <span class="course-pagination__separator"></span>
          <a href="LaunchTheProgram.html" class="course-pagination__btn">
            <span>Launch the program</span>
            <i class="fas fa-angle-right"></i>
          </a>
        </nav>

      </div>
    </div>

  </div>
</body>

<footer>
  <div align="center">
    <p>
      Brought to you by:
      <a class="laas_logo" href="https://www.laas.fr/public/">
        <img src="../../images/LogoLAAS-2016_BW.png " alt="LAAS-CNRS" height="60px"/>
      </a>
    </p>
  </div>
</footer>

</html>
